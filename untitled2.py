# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10Nz3p02XYksyaekl5zJONg7Rd-WHACFq
"""

!pip install ultralytics opencv-python pandas

from ultralytics import YOLO
import cv2
import pandas as pd
import numpy as np

model = YOLO("yolov8s.pt")  # lightweight= yolov8n, fast , changed to v8s , heavy but stable tradking

results = model.track(
    source="v.mp4",
    persist=True,
    conf=0.5,
    classes=[0],  # person class only
    save=False,
    stream=True
)

# now frame rules
for r in results:
    boxes = r.boxes
    if boxes is not None:
        for box in boxes:
            print("Player ID:", box.id)
    break  # sirf first frame test

data = []

cap = cv2.VideoCapture("v.mp4")
fps = cap.get(cv2.CAP_PROP_FPS)
frame_id = 0
frame_limit = 200

results = model.track(
    source="v.mp4",
    persist=True,
    conf=0.6,
    iou=0.4,
    classes=[0],
    tracker="bytetrack.yaml",
    imgsz=640,
    stream=True,
    max_det=50
)

for r in results:
    boxes = r.boxes
    if boxes is not None:
        for box in boxes:
            if box.id is not None:
                x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                player_id = int(box.id[0])
                x_center = float((x1 + x2) / 2)
                y_center = float((y1 + y2) / 2)

                data.append([
                    frame_id,
                    player_id,
                    x_center,
                    y_center,
                    frame_id / fps
                ])
    frame_id += 1

    if frame_id > frame_limit:
        break

cap.release()

df = pd.DataFrame(data, columns=[
    "frame_id",
    "player_id",
    "x_center",
    "y_center",
    "timestamp"
])

print("Total rows:", len(df))
print("Unique players:", df["player_id"].nunique())

print("\nTop 10 Player Frame Counts:")
print(df.groupby("player_id")["frame_id"].count().sort_values(ascending=False).head(10))

df = pd.DataFrame(data, columns=[
    "frame_id",
    "player_id",
    "x_center",
    "y_center",
    "timestamp"
])

df.to_csv("movement_data.csv", index=False)

print("CSV Saved Successfully")
df.head()

# ===== DEBUG SECTION =====

df = pd.read_csv("movement_data.csv")
df.head(20)



print("Total rows:", len(df))
print("Unique players detected:", df["player_id"].nunique())
print("Frame range:", df["frame_id"].min(), "to", df["frame_id"].max())


sample_player = df["player_id"].unique()[0]
df[df["player_id"] == sample_player].head(15) #Agar gap huge hai → tracking unstable.



df["player_id"].nunique()


frame_counts = df.groupby("player_id")["frame_id"].count().sort_values(ascending=False)
print(frame_counts.head(10))


#check tail:
print(frame_counts.tail(10))

# ===== DAY 2 : FIELD CALIBRATION (PIXEL → METERS) =====


# ===== IMPORT REQUIRED LIBRARIES FOR CALIBRATION =====

import cv2
import numpy as np
import matplotlib.pyplot as plt

# We will open the video again to extract one reference frame
# This frame will be used to manually identify 4 known field points

video_path = "v.mp4"  # <-- CHANGE THIS to video filename

cap = cv2.VideoCapture(video_path)

# Read the very first frame of the video
ret, frame = cap.read()

# Always check if frame was successfully read
if not ret:
    print("Error: Could not read video file.")
else:
    print("Frame loaded successfully.")

# Convert BGR (OpenCV default) to RGB (for proper matplotlib display)
frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

# Display the frame
plt.figure(figsize=(10, 6))
plt.imshow(frame_rgb)
plt.title("Reference Frame - Identify 4 Field Points")
plt.axis("off")

# ===== STEP 2: DISPLAY FRAME FOR MANUAL PIXEL INSPECTION =====

# This cell displays the frame clearly and allows you
# to hover your mouse over the image to read pixel coordinates.

import matplotlib.pyplot as plt

# Create a large figure so coordinates are easier to read
plt.figure(figsize=(12, 7))

# Show the RGB frame
plt.imshow(frame_rgb)

# Add a clear title explaining what to do
plt.title("Hover mouse over image to read pixel coordinates (see bottom of output)")

# Turn ON axis so pixel grid coordinates are visible
plt.axis("on")

# Do not show any grid overlay
plt.grid(False)

# Display the image
plt.show()

print("Move your mouse over the image.")
print("Read the x and y pixel values shown below the image.")
print("Note down 4 points carefully:")
print("1) Center of circle")
print("2) Right edge of circle")
print("3) Left edge of circle")
print("4) Top edge of circle")

# ===== STEP 3: DEFINE IMAGE POINTS (PIXELS) =====

# These are manually estimated from the displayed frame.
# Order must match the corresponding real-world points.

image_points = np.array([
    [385, 260],  # Center of circle
    [455, 260],  # Right edge of circle
    [315, 260],  # Left edge of circle
    [385, 190]   # Top edge of circle
], dtype=np.float32)

print("Image Points (pixels):")
print(image_points)

# ===== STEP 4: DEFINE REAL-WORLD POINTS (METERS) =====

# These correspond exactly to the image_points order

real_world_points = np.array([
    [0.0, 0.0],      # Center of circle
    [9.15, 0.0],     # Right edge of circle
    [-9.15, 0.0],    # Left edge of circle
    [0.0, 9.15]      # Top edge of circle
], dtype=np.float32)

print("Real World Points (meters):")
print(real_world_points)

# ===== STEP 5: COMPUTE HOMOGRAPHY MATRIX =====

# Homography maps pixel coordinates -> real world coordinates

H, status = cv2.findHomography(image_points, real_world_points)

print("Homography Matrix:")
print(H)

# ===== STEP 6: TRANSFORM ALL TRACKED PLAYER POSITIONS TO METERS =====

# Copy dataframe to avoid destroying original
df_real = df.copy()

# Function to convert pixel -> real world using homography
def pixel_to_meter(x, y, H):
    point = np.array([x, y, 1.0])
    transformed = H @ point

    # Normalize homogeneous coordinate
    X = transformed[0] / transformed[2]
    Y = transformed[1] / transformed[2]

    return X, Y

# Apply transformation row-wise
real_coords = df_real.apply(
    lambda row: pixel_to_meter(row["x_center"], row["y_center"], H),
    axis=1
)

# Split tuple output into two columns
df_real["x_meter"] = [coord[0] for coord in real_coords]
df_real["y_meter"] = [coord[1] for coord in real_coords]

print("Transformation complete.")
df_real.head()

df_real[df_real["player_id"] == 10].head()

print("X range:", df_real["x_meter"].min(), "to", df_real["x_meter"].max())
print("Y range:", df_real["y_meter"].min(), "to", df_real["y_meter"].max())

df_real.to_csv("movement_data_realworld.csv", index=False)

# ===== REVISED CALIBRATION: SIMPLE SCALE METHOD =====

# Known center pixel (from manual estimation)
center_x = 385
center_y = 260

# Pixel radius measured from image
pixel_radius = 70

# Real center circle radius in meters
real_radius = 9.15

# Compute meters per pixel
meters_per_pixel = real_radius / pixel_radius

print("Meters per pixel:", meters_per_pixel)

# ===== APPLY SIMPLE LINEAR TRANSFORMATION (STABLE) =====

df_real = df.copy()

# Convert X pixel to meters
df_real["x_meter"] = (df_real["x_center"] - center_x) * meters_per_pixel

# Convert Y pixel to meters (invert axis)
df_real["y_meter"] = (center_y - df_real["y_center"]) * meters_per_pixel

print("Linear calibration complete.")
df_real.head()

print("X range:", df_real["x_meter"].min(), "to", df_real["x_meter"].max())
print("Y range:", df_real["y_meter"].min(), "to", df_real["y_meter"].max())

# ===== SANITY CHECK: DISPLACEMENT OF ONE PLAYER =====

# Choose one frequent player
player_id_test = 10

player_data = df_real[df_real["player_id"] == player_id_test].sort_values("frame_id")

# Compute displacement between consecutive frames
player_data["dx"] = player_data["x_meter"].diff()
player_data["dy"] = player_data["y_meter"].diff()

# Euclidean distance per frame
player_data["frame_distance"] = (player_data["dx"]**2 + player_data["dy"]**2)**0.5

player_data.head()

# ===== COMPUTE SPEED (m/s) =====

# Ensure calculations are done for each player independently
df_real['dx'] = df_real.groupby('player_id')['x_meter'].diff()
df_real['dy'] = df_real.groupby('player_id')['y_meter'].diff()

# Euclidean distance per frame
df_real['frame_distance'] = (df_real['dx']**2 + df_real['dy']**2)**0.5

# Compute time difference between frames
df_real['dt'] = df_real.groupby('player_id')['timestamp'].diff()

# Speed = distance / time
df_real['speed_mps'] = df_real['frame_distance'] / df_real['dt']

# Display head for player_data (if still desired, otherwise can be removed)
# If you want to check for a specific player, re-filter df_real
player_id_test = 10
player_data = df_real[df_real["player_id"] == player_id_test].sort_values("frame_id")
player_data[["frame_id", "frame_distance", "dt", "speed_mps"]].head()


# ===== TOTAL DISTANCE PER PLAYER =====

total_distance = df_real.groupby("player_id")["frame_distance"].sum()

print(total_distance.sort_values(ascending=False).head())

# Check duration of video processed
print("Min timestamp:", df_real["timestamp"].min())
print("Max timestamp:", df_real["timestamp"].max())
print("Total duration (sec):", df_real["timestamp"].max() - df_real["timestamp"].min())

print("Max speed (m/s):", df_real["speed_mps"].max())

#Check frame count per player again:
print(df_real.groupby("player_id")["frame_id"].count().sort_values(ascending=False).head())

# ===== REMOVE UNREALISTIC SPEED SPIKES =====

# Define realistic upper speed threshold (m/s)
max_realistic_speed = 12

# Filter out rows where speed exceeds threshold
df_real_clean = df_real[df_real["speed_mps"] <= max_realistic_speed].copy()

print("Max speed after cleaning:", df_real_clean["speed_mps"].max())

# ===== TOTAL DISTANCE AFTER CLEANING =====

total_distance_clean = df_real_clean.groupby("player_id")["frame_distance"].sum()

print(total_distance_clean.sort_values(ascending=False).head())

# ===== REMOVE GHOST PLAYERS (LOW FRAME COUNT) =====

frame_counts = df_real_clean.groupby("player_id")["frame_id"].count()

valid_players = frame_counts[frame_counts > 30].index

df_final = df_real_clean[df_real_clean["player_id"].isin(valid_players)].copy()

print("Players kept:", list(valid_players))

total_distance_final = df_final.groupby("player_id")["frame_distance"].sum()

print(total_distance_final.sort_values(ascending=False))

df_final.to_csv("movement_data_realworld_final.csv", index=False)

"""# ===== DAY 3 : ANALYTICS MODULE =====

"""

# ===== PLAYER SUMMARY STATISTICS =====

# Aggregate key performance metrics per player
summary = df_final.groupby("player_id").agg({
    "frame_distance": "sum",
    "speed_mps": ["mean", "max"]
})

# Flatten multi-level column names
summary.columns = ["total_distance_m", "avg_speed_mps", "max_speed_mps"]

# Sort by total distance
summary = summary.sort_values("total_distance_m", ascending=False)

print("Player Performance Summary:")
summary

# ===== SPRINT DETECTION =====

# Define sprint threshold (m/s)
sprint_threshold = 7

# Mark sprint frames
df_final["is_sprint"] = df_final["speed_mps"] > sprint_threshold

# Count sprint frames per player
sprint_counts = df_final.groupby("player_id")["is_sprint"].sum()

print("Sprint Frames Per Player:")
print(sprint_counts.sort_values(ascending=False))

# ===== HEATMAP DATA PREPARATION =====

# Extract positional data for visualization
heatmap_data = df_final[["player_id", "x_meter", "y_meter"]].copy()

print("Heatmap data sample:")
heatmap_data.head()

import numpy as np
import pandas as pd

# ---- Ensure correct sorting ----
df_final = df_final.sort_values(["player_id", "timestamp"]).copy()

# ---- Remove invalid rows (first frame per player etc.) ----
df_valid = df_final.dropna(subset=["frame_distance", "dt"])

# ---- Aggregate per player ----
player_validation = (
    df_valid.groupby("player_id")
    .agg(
        total_distance_m=("frame_distance", "sum"),
        movement_duration_s=("dt", "sum"),
        mean_instant_speed=("speed_mps", "mean"),
        max_speed_mps=("speed_mps", "max"),
        frame_count=("frame_id", "count")
    )
    .reset_index()
)

# ---- Recompute average speed using physics definition ----
player_validation["recomputed_avg_speed_mps"] = (
    player_validation["total_distance_m"] /
    player_validation["movement_duration_s"]
)

# ---- Compare mean of instantaneous speeds vs physics definition ----
player_validation["percent_error"] = (
    abs(player_validation["mean_instant_speed"] -
        player_validation["recomputed_avg_speed_mps"]) /
    player_validation["recomputed_avg_speed_mps"]
) * 100

player_validation["speed_issue_flag"] = player_validation["percent_error"] > 5

print(player_validation)

print(df_final.columns)

print(df_final["speed_mps"].describe())

print(df_final["dt"].describe())
print((df_final["speed_mps"] < 1).mean())

df_final[df_final["dt"] > 0.05][["player_id", "frame_id", "dt"]]
print(df_final["frame_distance"].describe())

df_final.sort_values("frame_distance", ascending=False)[
    ["player_id", "frame_id", "frame_distance", "dt", "speed_mps"]
].head(10)

df_valid.groupby("player_id")["frame_id"].count().sort_values(ascending=False)

# ---- Stability & Reliability Metrics ----

import numpy as np

# Re-aggregate with standard deviation
player_stats = (
    df_valid.groupby("player_id")
    .agg(
        total_distance_m=("frame_distance", "sum"),
        movement_duration_s=("dt", "sum"),
        mean_speed=("speed_mps", "mean"),
        std_speed=("speed_mps", "std"),
        max_speed=("speed_mps", "max"),
        frame_count=("frame_id", "count")
    )
    .reset_index()
)

# Coefficient of Variation (movement consistency)
player_stats["cv_speed"] = player_stats["std_speed"] / player_stats["mean_speed"]

# Reliability score based on duration (normalized)
max_duration = player_stats["movement_duration_s"].max()
player_stats["confidence_score"] = (
    player_stats["movement_duration_s"] / max_duration
)

print(player_stats.sort_values("movement_duration_s", ascending=False))

# ---- Final Weighted Performance Model ----

import numpy as np
import pandas as pd

df_results = player_stats.copy()

# Avoid division explosion
epsilon = 1e-6

# Weighted performance score
df_results["performance_score"] = (
    df_results["mean_speed"] *
    df_results["confidence_score"] *
    (1 / (df_results["cv_speed"] + epsilon))
)

# Normalize score (0–100 scale for presentation)
max_score = df_results["performance_score"].max()
df_results["performance_score_normalized"] = (
    df_results["performance_score"] / max_score
) * 100


# ---- Performance Tier Classification ----
def classify(row):
    if row["confidence_score"] < 0.3:
        return "Low Confidence (Short Tracking)"
    elif row["cv_speed"] < 0.3:
        return "Highly Consistent"
    elif row["mean_speed"] > 7:
        return "Explosive"
    else:
        return "Balanced"

df_results["performance_category"] = df_results.apply(classify, axis=1)

# Final ranking
df_results = df_results.sort_values(
    "performance_score_normalized", ascending=False
).reset_index(drop=True)

print(df_results[[
    "player_id",
    "mean_speed",
    "movement_duration_s",
    "cv_speed",
    "confidence_score",
    "performance_score_normalized",
    "performance_category"
]])

import matplotlib.pyplot as plt

plt.figure()
plt.bar(df_results["player_id"].astype(str),
        df_results["performance_score_normalized"])
plt.xlabel("Player ID")
plt.ylabel("Performance Score (Normalized)")
plt.title("Weighted Player Performance Ranking")
plt.show()

# ---- Executive Summary Metrics ----

summary_metrics = {
    "Total Players": df_results.shape[0],
    "Total Frames Analyzed": int(df_valid.shape[0]),
    "Mean Tracking Duration (s)": round(df_results["movement_duration_s"].mean(), 2),
    "Max Tracking Duration (s)": round(df_results["movement_duration_s"].max(), 2),
    "Highest Recorded Speed (m/s)": round(df_valid["speed_mps"].max(), 2),
    "Overall Mean Speed (m/s)": round(df_valid["speed_mps"].mean(), 2)
}

for k, v in summary_metrics.items():
    print(f"{k}: {v}")

# ---- Sprint Analysis ----

sprint_analysis = (
    df_valid.groupby("player_id")
    .agg(
        sprint_ratio=("is_sprint", "mean"),
        sprint_count=("is_sprint", "sum")
    )
    .reset_index()
)

df_results = df_results.merge(sprint_analysis, on="player_id")

print(df_results[[
    "player_id",
    "performance_score_normalized",
    "sprint_ratio",
    "sprint_count"
]].sort_values("performance_score_normalized", ascending=False))

# ---- Robustness Test (Remove Large dt Gaps) ----

df_filtered = df_valid[df_valid["dt"] <= 0.08]

filtered_stats = (
    df_filtered.groupby("player_id")
    .agg(
        mean_speed_filtered=("speed_mps", "mean"),
        max_speed_filtered=("speed_mps", "max")
    )
    .reset_index()
)

comparison = df_results.merge(filtered_stats, on="player_id")

comparison["max_speed_change"] = (
    comparison["max_speed"] - comparison["max_speed_filtered"]
)

print(comparison[[
    "player_id",
    "max_speed",
    "max_speed_filtered",
    "max_speed_change"
]])

"""**Player Movement Performance Analysis**
- Objective
The goal of this analysis was to evaluate short-duration player movement performance using frame-level tracking data. The project aimed to compute physically consistent movement metrics (distance, speed), validate their correctness, assess statistical reliability, and construct a stability-aware performance ranking model.
The focus was on explosive movement behavior rather than endurance profiling, due to limited tracking durations.
Dataset Overview
Tracking frequency: ~25 FPS (dt ≈ 0.04s)
Total players analyzed: 11
Total frames analyzed: 1208
Maximum tracking duration (single player): ~7.7 seconds
Minimum tracking duration: ~1.5 seconds
Coordinates were converted into meters before distance computation.
Methodology

1. Kinematic Computation
Frame-to-frame displacement was computed using Euclidean distance:
distance = √(dx² + dy²)
Instantaneous speed was computed as:
speed = frame_distance / dt
Global average speed per player was validated using:
average_speed = total_distance / total_duration
Consistency checks confirmed that instantaneous averages and physics-based averages aligned.

2. Statistical Stability Assessment
Because tracking duration varied significantly across players (1.5s to 7.7s), performance comparisons required reliability adjustments.
The following metrics were introduced:
Mean Speed
Standard Deviation of Speed
Coefficient of Variation (CV = std / mean)
Confidence Score (duration normalized to maximum observed duration)
This allowed performance to be interpreted with statistical maturity instead of raw averages alone.

3. Weighted Performance Model
A composite performance score was constructed:
performance_score = mean_speed × confidence_score × (1 / cv_speed)
This formulation rewards:
Higher sustained speed
Longer tracking duration (more reliable data)
Lower volatility (movement consistency)
The model prevents short-duration bursts from unfairly dominating rankings.

4. Sprint Behavior Analysis
Sprint ratio and sprint count were computed per player to contextualize explosive behavior within overall movement.
This differentiates consistent movers from purely burst-driven performers.

5. Robustness Validation
Frames with large time gaps (dt > 0.08) were filtered to test sensitivity of peak speeds to frame skipping.
Minimal change in peak speeds confirmed that the model is structurally stable and not heavily dependent on dropped frames.
Key Findings
Movement speeds fall within realistic human sprint ranges (max ≈ 12 m/s).
Average speeds are physically consistent with sampling frequency.
Tracking duration significantly affects reliability of performance estimates.
Some players show high mean speeds but low confidence due to short observation windows.
Stability-aware scoring produces a more defensible ranking compared to raw averages.
Limitations
Very short tracking windows (≤ 8 seconds) prevent endurance conclusions.
Observations represent micro-movement behavior, not full match performance.
Sprint classification depends on chosen speed threshold.
Sample size imbalance introduces comparative bias.
Future Improvements
Extend tracking duration to full match segments.
Incorporate acceleration and deceleration metrics.
Add spatial heatmap analysis for positional context.
Introduce player clustering using unsupervised learning.
Validate results against real match statistics.
"""